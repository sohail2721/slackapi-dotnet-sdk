// <copyright file="ConversationsController.cs" company="APIMatic">
// SlackWebApi.Standard
//
// This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
// </copyright>
using APIMatic.Core;
using APIMatic.Core.Utilities;
using SlackWebApi.Standard.Exceptions;
using SlackWebApi.Standard.Http.Response;
using System.Net.Http;
using System.Threading;
using System.Threading.Tasks;

namespace SlackWebApi.Standard.Controllers
{
    /// <summary>
    /// ConversationsController.
    /// </summary>
    public class ConversationsController : BaseController
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="ConversationsController"/> class.
        /// </summary>
        internal ConversationsController(GlobalConfiguration globalConfiguration) : base(globalConfiguration) { }

        /// <summary>
        /// Archives a conversation.
        /// </summary>
        /// <param name="token">Optional parameter: Authentication token. Requires scope: `conversations:write`.</param>
        /// <param name="channel">Optional parameter: ID of conversation to archive.</param>
        /// <returns>Returns the ApiResponse of Models.ConversationsArchiveSuccessSchema response from the API call.</returns>
        public ApiResponse<Models.ConversationsArchiveSuccessSchema> ConversationsArchive(
                string token = null,
                string channel = null)
            => CoreHelper.RunTask(ConversationsArchiveAsync(token, channel));

        /// <summary>
        /// Archives a conversation.
        /// </summary>
        /// <param name="token">Optional parameter: Authentication token. Requires scope: `conversations:write`.</param>
        /// <param name="channel">Optional parameter: ID of conversation to archive.</param>
        /// <param name="cancellationToken"> cancellationToken. </param>
        /// <returns>Returns the ApiResponse of Models.ConversationsArchiveSuccessSchema response from the API call.</returns>
        public async Task<ApiResponse<Models.ConversationsArchiveSuccessSchema>> ConversationsArchiveAsync(
                string token = null,
                string channel = null,
                CancellationToken cancellationToken = default)
            => await CreateApiCall<Models.ConversationsArchiveSuccessSchema>()
              .RequestBuilder(requestBuilder => requestBuilder
                  .Setup(HttpMethod.Post, "/conversations.archive")
                  .WithAuth("slackAuth")
                  .Parameters(parameters => parameters
                      .Header(header => header.Setup("Content-Type", "application/x-www-form-urlencoded"))
                      .Header(header => header.Setup("token", token))
                      .Form(form => form.Setup("channel", channel))))
              .ResponseHandler(responseHandler => responseHandler
                  .ErrorCase("0", CreateErrorCase("Typical error response", (errorReason, context) => new ConversationsArchiveErrorSchemaException(errorReason, context))))
              .ExecuteAsync(cancellationToken).ConfigureAwait(false);

        /// <summary>
        /// Closes a direct message or multi-person direct message.
        /// </summary>
        /// <param name="token">Optional parameter: Authentication token. Requires scope: `conversations:write`.</param>
        /// <param name="channel">Optional parameter: Conversation to close..</param>
        /// <returns>Returns the ApiResponse of Models.ConversationsCloseSuccessSchema response from the API call.</returns>
        public ApiResponse<Models.ConversationsCloseSuccessSchema> ConversationsClose(
                string token = null,
                string channel = null)
            => CoreHelper.RunTask(ConversationsCloseAsync(token, channel));

        /// <summary>
        /// Closes a direct message or multi-person direct message.
        /// </summary>
        /// <param name="token">Optional parameter: Authentication token. Requires scope: `conversations:write`.</param>
        /// <param name="channel">Optional parameter: Conversation to close..</param>
        /// <param name="cancellationToken"> cancellationToken. </param>
        /// <returns>Returns the ApiResponse of Models.ConversationsCloseSuccessSchema response from the API call.</returns>
        public async Task<ApiResponse<Models.ConversationsCloseSuccessSchema>> ConversationsCloseAsync(
                string token = null,
                string channel = null,
                CancellationToken cancellationToken = default)
            => await CreateApiCall<Models.ConversationsCloseSuccessSchema>()
              .RequestBuilder(requestBuilder => requestBuilder
                  .Setup(HttpMethod.Post, "/conversations.close")
                  .WithAuth("slackAuth")
                  .Parameters(parameters => parameters
                      .Header(header => header.Setup("Content-Type", "application/x-www-form-urlencoded"))
                      .Header(header => header.Setup("token", token))
                      .Form(form => form.Setup("channel", channel))))
              .ResponseHandler(responseHandler => responseHandler
                  .ErrorCase("0", CreateErrorCase("Typical error response", (errorReason, context) => new ConversationsCloseErrorSchemaException(errorReason, context))))
              .ExecuteAsync(cancellationToken).ConfigureAwait(false);

        /// <summary>
        /// Initiates a public or private channel-based conversation.
        /// </summary>
        /// <param name="token">Optional parameter: Authentication token. Requires scope: `conversations:write`.</param>
        /// <param name="name">Optional parameter: Name of the public or private channel to create.</param>
        /// <param name="isPrivate">Optional parameter: Create a private channel instead of a public one.</param>
        /// <returns>Returns the ApiResponse of Models.ConversationsCreateSuccessSchema response from the API call.</returns>
        public ApiResponse<Models.ConversationsCreateSuccessSchema> ConversationsCreate(
                string token = null,
                string name = null,
                bool? isPrivate = null)
            => CoreHelper.RunTask(ConversationsCreateAsync(token, name, isPrivate));

        /// <summary>
        /// Initiates a public or private channel-based conversation.
        /// </summary>
        /// <param name="token">Optional parameter: Authentication token. Requires scope: `conversations:write`.</param>
        /// <param name="name">Optional parameter: Name of the public or private channel to create.</param>
        /// <param name="isPrivate">Optional parameter: Create a private channel instead of a public one.</param>
        /// <param name="cancellationToken"> cancellationToken. </param>
        /// <returns>Returns the ApiResponse of Models.ConversationsCreateSuccessSchema response from the API call.</returns>
        public async Task<ApiResponse<Models.ConversationsCreateSuccessSchema>> ConversationsCreateAsync(
                string token = null,
                string name = null,
                bool? isPrivate = null,
                CancellationToken cancellationToken = default)
            => await CreateApiCall<Models.ConversationsCreateSuccessSchema>()
              .RequestBuilder(requestBuilder => requestBuilder
                  .Setup(HttpMethod.Post, "/conversations.create")
                  .WithAuth("slackAuth")
                  .Parameters(parameters => parameters
                      .Header(header => header.Setup("Content-Type", "application/x-www-form-urlencoded"))
                      .Header(header => header.Setup("token", token))
                      .Form(form => form.Setup("name", name))
                      .Form(form => form.Setup("is_private", isPrivate))))
              .ResponseHandler(responseHandler => responseHandler
                  .ErrorCase("0", CreateErrorCase("Typical error response when name already in use", (errorReason, context) => new ConversationsCreateErrorSchemaException(errorReason, context))))
              .ExecuteAsync(cancellationToken).ConfigureAwait(false);

        /// <summary>
        /// Fetches a conversation's history of messages and events.
        /// </summary>
        /// <param name="token">Optional parameter: Authentication token. Requires scope: `conversations:history`.</param>
        /// <param name="channel">Optional parameter: Conversation ID to fetch history for..</param>
        /// <param name="latest">Optional parameter: End of time range of messages to include in results..</param>
        /// <param name="oldest">Optional parameter: Start of time range of messages to include in results..</param>
        /// <param name="inclusive">Optional parameter: Include messages with latest or oldest timestamp in results only when either timestamp is specified..</param>
        /// <param name="limit">Optional parameter: The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the users list hasn't been reached..</param>
        /// <param name="cursor">Optional parameter: Paginate through collections of data by setting the `cursor` parameter to a `next_cursor` attribute returned by a previous request's `response_metadata`. Default value fetches the first "page" of the collection. See [pagination](/docs/pagination) for more detail..</param>
        /// <returns>Returns the ApiResponse of Models.ConversationsHistorySuccessSchema response from the API call.</returns>
        public ApiResponse<Models.ConversationsHistorySuccessSchema> ConversationsHistory(
                string token = null,
                string channel = null,
                double? latest = null,
                double? oldest = null,
                bool? inclusive = null,
                int? limit = null,
                string cursor = null)
            => CoreHelper.RunTask(ConversationsHistoryAsync(token, channel, latest, oldest, inclusive, limit, cursor));

        /// <summary>
        /// Fetches a conversation's history of messages and events.
        /// </summary>
        /// <param name="token">Optional parameter: Authentication token. Requires scope: `conversations:history`.</param>
        /// <param name="channel">Optional parameter: Conversation ID to fetch history for..</param>
        /// <param name="latest">Optional parameter: End of time range of messages to include in results..</param>
        /// <param name="oldest">Optional parameter: Start of time range of messages to include in results..</param>
        /// <param name="inclusive">Optional parameter: Include messages with latest or oldest timestamp in results only when either timestamp is specified..</param>
        /// <param name="limit">Optional parameter: The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the users list hasn't been reached..</param>
        /// <param name="cursor">Optional parameter: Paginate through collections of data by setting the `cursor` parameter to a `next_cursor` attribute returned by a previous request's `response_metadata`. Default value fetches the first "page" of the collection. See [pagination](/docs/pagination) for more detail..</param>
        /// <param name="cancellationToken"> cancellationToken. </param>
        /// <returns>Returns the ApiResponse of Models.ConversationsHistorySuccessSchema response from the API call.</returns>
        public async Task<ApiResponse<Models.ConversationsHistorySuccessSchema>> ConversationsHistoryAsync(
                string token = null,
                string channel = null,
                double? latest = null,
                double? oldest = null,
                bool? inclusive = null,
                int? limit = null,
                string cursor = null,
                CancellationToken cancellationToken = default)
            => await CreateApiCall<Models.ConversationsHistorySuccessSchema>()
              .RequestBuilder(requestBuilder => requestBuilder
                  .Setup(HttpMethod.Get, "/conversations.history")
                  .WithAuth("slackAuth")
                  .Parameters(parameters => parameters
                      .Header(header => header.Setup("Content-Type", "application/x-www-form-urlencoded"))
                      .Query(query => query.Setup("token", token))
                      .Query(query => query.Setup("channel", channel))
                      .Query(query => query.Setup("latest", latest))
                      .Query(query => query.Setup("oldest", oldest))
                      .Query(query => query.Setup("inclusive", inclusive))
                      .Query(query => query.Setup("limit", limit))
                      .Query(query => query.Setup("cursor", cursor))))
              .ResponseHandler(responseHandler => responseHandler
                  .ErrorCase("0", CreateErrorCase("Typical error response", (errorReason, context) => new ConversationsHistoryErrorSchemaException(errorReason, context))))
              .ExecuteAsync(cancellationToken).ConfigureAwait(false);

        /// <summary>
        /// Retrieve information about a conversation.
        /// </summary>
        /// <param name="token">Optional parameter: Authentication token. Requires scope: `conversations:read`.</param>
        /// <param name="channel">Optional parameter: Conversation ID to learn more about.</param>
        /// <param name="includeLocale">Optional parameter: Set this to `true` to receive the locale for this conversation. Defaults to `false`.</param>
        /// <param name="includeNumMembers">Optional parameter: Set to `true` to include the member count for the specified conversation. Defaults to `false`.</param>
        /// <returns>Returns the ApiResponse of Models.ConversationsInfoSuccessSchema response from the API call.</returns>
        public ApiResponse<Models.ConversationsInfoSuccessSchema> ConversationsInfo(
                string token = null,
                string channel = null,
                bool? includeLocale = null,
                bool? includeNumMembers = null)
            => CoreHelper.RunTask(ConversationsInfoAsync(token, channel, includeLocale, includeNumMembers));

        /// <summary>
        /// Retrieve information about a conversation.
        /// </summary>
        /// <param name="token">Optional parameter: Authentication token. Requires scope: `conversations:read`.</param>
        /// <param name="channel">Optional parameter: Conversation ID to learn more about.</param>
        /// <param name="includeLocale">Optional parameter: Set this to `true` to receive the locale for this conversation. Defaults to `false`.</param>
        /// <param name="includeNumMembers">Optional parameter: Set to `true` to include the member count for the specified conversation. Defaults to `false`.</param>
        /// <param name="cancellationToken"> cancellationToken. </param>
        /// <returns>Returns the ApiResponse of Models.ConversationsInfoSuccessSchema response from the API call.</returns>
        public async Task<ApiResponse<Models.ConversationsInfoSuccessSchema>> ConversationsInfoAsync(
                string token = null,
                string channel = null,
                bool? includeLocale = null,
                bool? includeNumMembers = null,
                CancellationToken cancellationToken = default)
            => await CreateApiCall<Models.ConversationsInfoSuccessSchema>()
              .RequestBuilder(requestBuilder => requestBuilder
                  .Setup(HttpMethod.Get, "/conversations.info")
                  .WithAuth("slackAuth")
                  .Parameters(parameters => parameters
                      .Header(header => header.Setup("Content-Type", "application/x-www-form-urlencoded"))
                      .Query(query => query.Setup("token", token))
                      .Query(query => query.Setup("channel", channel))
                      .Query(query => query.Setup("include_locale", includeLocale))
                      .Query(query => query.Setup("include_num_members", includeNumMembers))))
              .ResponseHandler(responseHandler => responseHandler
                  .ErrorCase("0", CreateErrorCase("Typical error response when a channel cannot be found", (errorReason, context) => new ConversationsInfoErrorSchemaException(errorReason, context))))
              .ExecuteAsync(cancellationToken).ConfigureAwait(false);

        /// <summary>
        /// Invites users to a channel.
        /// </summary>
        /// <param name="token">Optional parameter: Authentication token. Requires scope: `conversations:write`.</param>
        /// <param name="channel">Optional parameter: The ID of the public or private channel to invite user(s) to..</param>
        /// <param name="users">Optional parameter: A comma separated list of user IDs. Up to 1000 users may be listed..</param>
        /// <returns>Returns the ApiResponse of Models.ConversationsInviteErrorSchema response from the API call.</returns>
        public ApiResponse<Models.ConversationsInviteErrorSchema> ConversationsInvite(
                string token = null,
                string channel = null,
                string users = null)
            => CoreHelper.RunTask(ConversationsInviteAsync(token, channel, users));

        /// <summary>
        /// Invites users to a channel.
        /// </summary>
        /// <param name="token">Optional parameter: Authentication token. Requires scope: `conversations:write`.</param>
        /// <param name="channel">Optional parameter: The ID of the public or private channel to invite user(s) to..</param>
        /// <param name="users">Optional parameter: A comma separated list of user IDs. Up to 1000 users may be listed..</param>
        /// <param name="cancellationToken"> cancellationToken. </param>
        /// <returns>Returns the ApiResponse of Models.ConversationsInviteErrorSchema response from the API call.</returns>
        public async Task<ApiResponse<Models.ConversationsInviteErrorSchema>> ConversationsInviteAsync(
                string token = null,
                string channel = null,
                string users = null,
                CancellationToken cancellationToken = default)
            => await CreateApiCall<Models.ConversationsInviteErrorSchema>()
              .RequestBuilder(requestBuilder => requestBuilder
                  .Setup(HttpMethod.Post, "/conversations.invite")
                  .WithAuth("slackAuth")
                  .Parameters(parameters => parameters
                      .Header(header => header.Setup("Content-Type", "application/x-www-form-urlencoded"))
                      .Header(header => header.Setup("token", token))
                      .Form(form => form.Setup("channel", channel))
                      .Form(form => form.Setup("users", users))))
              .ResponseHandler(responseHandler => responseHandler
                  .ErrorCase("0", CreateErrorCase("Typical error response when an invite is attempted on a conversation type that does not support it", (errorReason, context) => new ConversationsInviteErrorSchema1Exception(errorReason, context))))
              .ExecuteAsync(cancellationToken).ConfigureAwait(false);

        /// <summary>
        /// Joins an existing conversation.
        /// </summary>
        /// <param name="token">Optional parameter: Authentication token. Requires scope: `channels:write`.</param>
        /// <param name="channel">Optional parameter: ID of conversation to join.</param>
        /// <returns>Returns the ApiResponse of Models.ConversationsJoinSuccessSchema response from the API call.</returns>
        public ApiResponse<Models.ConversationsJoinSuccessSchema> ConversationsJoin(
                string token = null,
                string channel = null)
            => CoreHelper.RunTask(ConversationsJoinAsync(token, channel));

        /// <summary>
        /// Joins an existing conversation.
        /// </summary>
        /// <param name="token">Optional parameter: Authentication token. Requires scope: `channels:write`.</param>
        /// <param name="channel">Optional parameter: ID of conversation to join.</param>
        /// <param name="cancellationToken"> cancellationToken. </param>
        /// <returns>Returns the ApiResponse of Models.ConversationsJoinSuccessSchema response from the API call.</returns>
        public async Task<ApiResponse<Models.ConversationsJoinSuccessSchema>> ConversationsJoinAsync(
                string token = null,
                string channel = null,
                CancellationToken cancellationToken = default)
            => await CreateApiCall<Models.ConversationsJoinSuccessSchema>()
              .RequestBuilder(requestBuilder => requestBuilder
                  .Setup(HttpMethod.Post, "/conversations.join")
                  .WithAuth("slackAuth")
                  .Parameters(parameters => parameters
                      .Header(header => header.Setup("Content-Type", "application/x-www-form-urlencoded"))
                      .Header(header => header.Setup("token", token))
                      .Form(form => form.Setup("channel", channel))))
              .ResponseHandler(responseHandler => responseHandler
                  .ErrorCase("0", CreateErrorCase("Typical error response if the conversation is archived and cannot be joined", (errorReason, context) => new ConversationsJoinErrorSchemaException(errorReason, context))))
              .ExecuteAsync(cancellationToken).ConfigureAwait(false);

        /// <summary>
        /// Removes a user from a conversation.
        /// </summary>
        /// <param name="token">Optional parameter: Authentication token. Requires scope: `conversations:write`.</param>
        /// <param name="channel">Optional parameter: ID of conversation to remove user from..</param>
        /// <param name="user">Optional parameter: User ID to be removed..</param>
        /// <returns>Returns the ApiResponse of Models.ConversationsKickSuccessSchema response from the API call.</returns>
        public ApiResponse<Models.ConversationsKickSuccessSchema> ConversationsKick(
                string token = null,
                string channel = null,
                string user = null)
            => CoreHelper.RunTask(ConversationsKickAsync(token, channel, user));

        /// <summary>
        /// Removes a user from a conversation.
        /// </summary>
        /// <param name="token">Optional parameter: Authentication token. Requires scope: `conversations:write`.</param>
        /// <param name="channel">Optional parameter: ID of conversation to remove user from..</param>
        /// <param name="user">Optional parameter: User ID to be removed..</param>
        /// <param name="cancellationToken"> cancellationToken. </param>
        /// <returns>Returns the ApiResponse of Models.ConversationsKickSuccessSchema response from the API call.</returns>
        public async Task<ApiResponse<Models.ConversationsKickSuccessSchema>> ConversationsKickAsync(
                string token = null,
                string channel = null,
                string user = null,
                CancellationToken cancellationToken = default)
            => await CreateApiCall<Models.ConversationsKickSuccessSchema>()
              .RequestBuilder(requestBuilder => requestBuilder
                  .Setup(HttpMethod.Post, "/conversations.kick")
                  .WithAuth("slackAuth")
                  .Parameters(parameters => parameters
                      .Header(header => header.Setup("Content-Type", "application/x-www-form-urlencoded"))
                      .Header(header => header.Setup("token", token))
                      .Form(form => form.Setup("channel", channel))
                      .Form(form => form.Setup("user", user))))
              .ResponseHandler(responseHandler => responseHandler
                  .ErrorCase("0", CreateErrorCase("Typical error response when you attempt to kick yourself from a channel", (errorReason, context) => new ConversationsKickErrorSchemaException(errorReason, context))))
              .ExecuteAsync(cancellationToken).ConfigureAwait(false);

        /// <summary>
        /// Leaves a conversation.
        /// </summary>
        /// <param name="token">Optional parameter: Authentication token. Requires scope: `conversations:write`.</param>
        /// <param name="channel">Optional parameter: Conversation to leave.</param>
        /// <returns>Returns the ApiResponse of Models.ConversationsLeaveSuccessSchema response from the API call.</returns>
        public ApiResponse<Models.ConversationsLeaveSuccessSchema> ConversationsLeave(
                string token = null,
                string channel = null)
            => CoreHelper.RunTask(ConversationsLeaveAsync(token, channel));

        /// <summary>
        /// Leaves a conversation.
        /// </summary>
        /// <param name="token">Optional parameter: Authentication token. Requires scope: `conversations:write`.</param>
        /// <param name="channel">Optional parameter: Conversation to leave.</param>
        /// <param name="cancellationToken"> cancellationToken. </param>
        /// <returns>Returns the ApiResponse of Models.ConversationsLeaveSuccessSchema response from the API call.</returns>
        public async Task<ApiResponse<Models.ConversationsLeaveSuccessSchema>> ConversationsLeaveAsync(
                string token = null,
                string channel = null,
                CancellationToken cancellationToken = default)
            => await CreateApiCall<Models.ConversationsLeaveSuccessSchema>()
              .RequestBuilder(requestBuilder => requestBuilder
                  .Setup(HttpMethod.Post, "/conversations.leave")
                  .WithAuth("slackAuth")
                  .Parameters(parameters => parameters
                      .Header(header => header.Setup("Content-Type", "application/x-www-form-urlencoded"))
                      .Header(header => header.Setup("token", token))
                      .Form(form => form.Setup("channel", channel))))
              .ResponseHandler(responseHandler => responseHandler
                  .ErrorCase("0", CreateErrorCase("Typical error response when attempting to leave a workspace's \"general\" channel", (errorReason, context) => new ConversationsLeaveErrorSchemaException(errorReason, context))))
              .ExecuteAsync(cancellationToken).ConfigureAwait(false);

        /// <summary>
        /// Lists all channels in a Slack team.
        /// </summary>
        /// <param name="token">Optional parameter: Authentication token. Requires scope: `conversations:read`.</param>
        /// <param name="excludeArchived">Optional parameter: Set to `true` to exclude archived channels from the list.</param>
        /// <param name="types">Optional parameter: Mix and match channel types by providing a comma-separated list of any combination of `public_channel`, `private_channel`, `mpim`, `im`.</param>
        /// <param name="limit">Optional parameter: The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the list hasn't been reached. Must be an integer no larger than 1000..</param>
        /// <param name="cursor">Optional parameter: Paginate through collections of data by setting the `cursor` parameter to a `next_cursor` attribute returned by a previous request's `response_metadata`. Default value fetches the first "page" of the collection. See [pagination](/docs/pagination) for more detail..</param>
        /// <returns>Returns the ApiResponse of Models.ConversationsListSuccessSchema response from the API call.</returns>
        public ApiResponse<Models.ConversationsListSuccessSchema> ConversationsList(
                string token = null,
                bool? excludeArchived = null,
                string types = null,
                int? limit = null,
                string cursor = null)
            => CoreHelper.RunTask(ConversationsListAsync(token, excludeArchived, types, limit, cursor));

        /// <summary>
        /// Lists all channels in a Slack team.
        /// </summary>
        /// <param name="token">Optional parameter: Authentication token. Requires scope: `conversations:read`.</param>
        /// <param name="excludeArchived">Optional parameter: Set to `true` to exclude archived channels from the list.</param>
        /// <param name="types">Optional parameter: Mix and match channel types by providing a comma-separated list of any combination of `public_channel`, `private_channel`, `mpim`, `im`.</param>
        /// <param name="limit">Optional parameter: The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the list hasn't been reached. Must be an integer no larger than 1000..</param>
        /// <param name="cursor">Optional parameter: Paginate through collections of data by setting the `cursor` parameter to a `next_cursor` attribute returned by a previous request's `response_metadata`. Default value fetches the first "page" of the collection. See [pagination](/docs/pagination) for more detail..</param>
        /// <param name="cancellationToken"> cancellationToken. </param>
        /// <returns>Returns the ApiResponse of Models.ConversationsListSuccessSchema response from the API call.</returns>
        public async Task<ApiResponse<Models.ConversationsListSuccessSchema>> ConversationsListAsync(
                string token = null,
                bool? excludeArchived = null,
                string types = null,
                int? limit = null,
                string cursor = null,
                CancellationToken cancellationToken = default)
            => await CreateApiCall<Models.ConversationsListSuccessSchema>()
              .RequestBuilder(requestBuilder => requestBuilder
                  .Setup(HttpMethod.Get, "/conversations.list")
                  .WithAuth("slackAuth")
                  .Parameters(parameters => parameters
                      .Header(header => header.Setup("Content-Type", "application/x-www-form-urlencoded"))
                      .Query(query => query.Setup("token", token))
                      .Query(query => query.Setup("exclude_archived", excludeArchived))
                      .Query(query => query.Setup("types", types))
                      .Query(query => query.Setup("limit", limit))
                      .Query(query => query.Setup("cursor", cursor))))
              .ResponseHandler(responseHandler => responseHandler
                  .ErrorCase("0", CreateErrorCase("Typical error response", (errorReason, context) => new ConversationsListErrorSchemaException(errorReason, context))))
              .ExecuteAsync(cancellationToken).ConfigureAwait(false);

        /// <summary>
        /// Sets the read cursor in a channel.
        /// </summary>
        /// <param name="token">Optional parameter: Authentication token. Requires scope: `conversations:write`.</param>
        /// <param name="channel">Optional parameter: Channel or conversation to set the read cursor for..</param>
        /// <param name="ts">Optional parameter: Unique identifier of message you want marked as most recently seen in this conversation..</param>
        /// <returns>Returns the ApiResponse of Models.ConversationsMarkSuccessSchema response from the API call.</returns>
        public ApiResponse<Models.ConversationsMarkSuccessSchema> ConversationsMark(
                string token = null,
                string channel = null,
                double? ts = null)
            => CoreHelper.RunTask(ConversationsMarkAsync(token, channel, ts));

        /// <summary>
        /// Sets the read cursor in a channel.
        /// </summary>
        /// <param name="token">Optional parameter: Authentication token. Requires scope: `conversations:write`.</param>
        /// <param name="channel">Optional parameter: Channel or conversation to set the read cursor for..</param>
        /// <param name="ts">Optional parameter: Unique identifier of message you want marked as most recently seen in this conversation..</param>
        /// <param name="cancellationToken"> cancellationToken. </param>
        /// <returns>Returns the ApiResponse of Models.ConversationsMarkSuccessSchema response from the API call.</returns>
        public async Task<ApiResponse<Models.ConversationsMarkSuccessSchema>> ConversationsMarkAsync(
                string token = null,
                string channel = null,
                double? ts = null,
                CancellationToken cancellationToken = default)
            => await CreateApiCall<Models.ConversationsMarkSuccessSchema>()
              .RequestBuilder(requestBuilder => requestBuilder
                  .Setup(HttpMethod.Post, "/conversations.mark")
                  .WithAuth("slackAuth")
                  .Parameters(parameters => parameters
                      .Header(header => header.Setup("Content-Type", "application/x-www-form-urlencoded"))
                      .Header(header => header.Setup("token", token))
                      .Form(form => form.Setup("channel", channel))
                      .Form(form => form.Setup("ts", ts))))
              .ResponseHandler(responseHandler => responseHandler
                  .ErrorCase("0", CreateErrorCase("Typical error response", (errorReason, context) => new ConversationsMarkErrorSchemaException(errorReason, context))))
              .ExecuteAsync(cancellationToken).ConfigureAwait(false);

        /// <summary>
        /// Retrieve members of a conversation.
        /// </summary>
        /// <param name="token">Optional parameter: Authentication token. Requires scope: `conversations:read`.</param>
        /// <param name="channel">Optional parameter: ID of the conversation to retrieve members for.</param>
        /// <param name="limit">Optional parameter: The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the users list hasn't been reached..</param>
        /// <param name="cursor">Optional parameter: Paginate through collections of data by setting the `cursor` parameter to a `next_cursor` attribute returned by a previous request's `response_metadata`. Default value fetches the first "page" of the collection. See [pagination](/docs/pagination) for more detail..</param>
        /// <returns>Returns the ApiResponse of Models.ConversationsMembersSuccessSchema response from the API call.</returns>
        public ApiResponse<Models.ConversationsMembersSuccessSchema> ConversationsMembers(
                string token = null,
                string channel = null,
                int? limit = null,
                string cursor = null)
            => CoreHelper.RunTask(ConversationsMembersAsync(token, channel, limit, cursor));

        /// <summary>
        /// Retrieve members of a conversation.
        /// </summary>
        /// <param name="token">Optional parameter: Authentication token. Requires scope: `conversations:read`.</param>
        /// <param name="channel">Optional parameter: ID of the conversation to retrieve members for.</param>
        /// <param name="limit">Optional parameter: The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the users list hasn't been reached..</param>
        /// <param name="cursor">Optional parameter: Paginate through collections of data by setting the `cursor` parameter to a `next_cursor` attribute returned by a previous request's `response_metadata`. Default value fetches the first "page" of the collection. See [pagination](/docs/pagination) for more detail..</param>
        /// <param name="cancellationToken"> cancellationToken. </param>
        /// <returns>Returns the ApiResponse of Models.ConversationsMembersSuccessSchema response from the API call.</returns>
        public async Task<ApiResponse<Models.ConversationsMembersSuccessSchema>> ConversationsMembersAsync(
                string token = null,
                string channel = null,
                int? limit = null,
                string cursor = null,
                CancellationToken cancellationToken = default)
            => await CreateApiCall<Models.ConversationsMembersSuccessSchema>()
              .RequestBuilder(requestBuilder => requestBuilder
                  .Setup(HttpMethod.Get, "/conversations.members")
                  .WithAuth("slackAuth")
                  .Parameters(parameters => parameters
                      .Header(header => header.Setup("Content-Type", "application/x-www-form-urlencoded"))
                      .Query(query => query.Setup("token", token))
                      .Query(query => query.Setup("channel", channel))
                      .Query(query => query.Setup("limit", limit))
                      .Query(query => query.Setup("cursor", cursor))))
              .ResponseHandler(responseHandler => responseHandler
                  .ErrorCase("0", CreateErrorCase("Typical error response when an invalid cursor is provided", (errorReason, context) => new ConversationsMembersErrorSchemaException(errorReason, context))))
              .ExecuteAsync(cancellationToken).ConfigureAwait(false);

        /// <summary>
        /// Opens or resumes a direct message or multi-person direct message.
        /// </summary>
        /// <param name="token">Optional parameter: Authentication token. Requires scope: `conversations:write`.</param>
        /// <param name="channel">Optional parameter: Resume a conversation by supplying an `im` or `mpim`'s ID. Or provide the `users` field instead..</param>
        /// <param name="users">Optional parameter: Comma separated lists of users. If only one user is included, this creates a 1:1 DM.  The ordering of the users is preserved whenever a multi-person direct message is returned. Supply a `channel` when not supplying `users`..</param>
        /// <param name="returnIm">Optional parameter: Boolean, indicates you want the full IM channel definition in the response..</param>
        /// <returns>Returns the ApiResponse of Models.ConversationsOpenSuccessSchema response from the API call.</returns>
        public ApiResponse<Models.ConversationsOpenSuccessSchema> ConversationsOpen(
                string token = null,
                string channel = null,
                string users = null,
                bool? returnIm = null)
            => CoreHelper.RunTask(ConversationsOpenAsync(token, channel, users, returnIm));

        /// <summary>
        /// Opens or resumes a direct message or multi-person direct message.
        /// </summary>
        /// <param name="token">Optional parameter: Authentication token. Requires scope: `conversations:write`.</param>
        /// <param name="channel">Optional parameter: Resume a conversation by supplying an `im` or `mpim`'s ID. Or provide the `users` field instead..</param>
        /// <param name="users">Optional parameter: Comma separated lists of users. If only one user is included, this creates a 1:1 DM.  The ordering of the users is preserved whenever a multi-person direct message is returned. Supply a `channel` when not supplying `users`..</param>
        /// <param name="returnIm">Optional parameter: Boolean, indicates you want the full IM channel definition in the response..</param>
        /// <param name="cancellationToken"> cancellationToken. </param>
        /// <returns>Returns the ApiResponse of Models.ConversationsOpenSuccessSchema response from the API call.</returns>
        public async Task<ApiResponse<Models.ConversationsOpenSuccessSchema>> ConversationsOpenAsync(
                string token = null,
                string channel = null,
                string users = null,
                bool? returnIm = null,
                CancellationToken cancellationToken = default)
            => await CreateApiCall<Models.ConversationsOpenSuccessSchema>()
              .RequestBuilder(requestBuilder => requestBuilder
                  .Setup(HttpMethod.Post, "/conversations.open")
                  .WithAuth("slackAuth")
                  .Parameters(parameters => parameters
                      .Header(header => header.Setup("Content-Type", "application/x-www-form-urlencoded"))
                      .Header(header => header.Setup("token", token))
                      .Form(form => form.Setup("channel", channel))
                      .Form(form => form.Setup("users", users))
                      .Form(form => form.Setup("return_im", returnIm))))
              .ResponseHandler(responseHandler => responseHandler
                  .ErrorCase("0", CreateErrorCase("Typical error response", (errorReason, context) => new ConversationsOpenErrorSchemaException(errorReason, context))))
              .ExecuteAsync(cancellationToken).ConfigureAwait(false);

        /// <summary>
        /// Renames a conversation.
        /// </summary>
        /// <param name="token">Optional parameter: Authentication token. Requires scope: `conversations:write`.</param>
        /// <param name="channel">Optional parameter: ID of conversation to rename.</param>
        /// <param name="name">Optional parameter: New name for conversation..</param>
        /// <returns>Returns the ApiResponse of Models.ConversationsRenameSuccessSchema response from the API call.</returns>
        public ApiResponse<Models.ConversationsRenameSuccessSchema> ConversationsRename(
                string token = null,
                string channel = null,
                string name = null)
            => CoreHelper.RunTask(ConversationsRenameAsync(token, channel, name));

        /// <summary>
        /// Renames a conversation.
        /// </summary>
        /// <param name="token">Optional parameter: Authentication token. Requires scope: `conversations:write`.</param>
        /// <param name="channel">Optional parameter: ID of conversation to rename.</param>
        /// <param name="name">Optional parameter: New name for conversation..</param>
        /// <param name="cancellationToken"> cancellationToken. </param>
        /// <returns>Returns the ApiResponse of Models.ConversationsRenameSuccessSchema response from the API call.</returns>
        public async Task<ApiResponse<Models.ConversationsRenameSuccessSchema>> ConversationsRenameAsync(
                string token = null,
                string channel = null,
                string name = null,
                CancellationToken cancellationToken = default)
            => await CreateApiCall<Models.ConversationsRenameSuccessSchema>()
              .RequestBuilder(requestBuilder => requestBuilder
                  .Setup(HttpMethod.Post, "/conversations.rename")
                  .WithAuth("slackAuth")
                  .Parameters(parameters => parameters
                      .Header(header => header.Setup("Content-Type", "application/x-www-form-urlencoded"))
                      .Header(header => header.Setup("token", token))
                      .Form(form => form.Setup("channel", channel))
                      .Form(form => form.Setup("name", name))))
              .ResponseHandler(responseHandler => responseHandler
                  .ErrorCase("0", CreateErrorCase("Typical error response when the calling user is not a member of the conversation", (errorReason, context) => new ConversationsRenameErrorSchemaException(errorReason, context))))
              .ExecuteAsync(cancellationToken).ConfigureAwait(false);

        /// <summary>
        /// Retrieve a thread of messages posted to a conversation.
        /// </summary>
        /// <param name="token">Optional parameter: Authentication token. Requires scope: `conversations:history`.</param>
        /// <param name="channel">Optional parameter: Conversation ID to fetch thread from..</param>
        /// <param name="ts">Optional parameter: Unique identifier of a thread's parent message. `ts` must be the timestamp of an existing message with 0 or more replies. If there are no replies then just the single message referenced by `ts` will return - it is just an ordinary, unthreaded message..</param>
        /// <param name="latest">Optional parameter: End of time range of messages to include in results..</param>
        /// <param name="oldest">Optional parameter: Start of time range of messages to include in results..</param>
        /// <param name="inclusive">Optional parameter: Include messages with latest or oldest timestamp in results only when either timestamp is specified..</param>
        /// <param name="limit">Optional parameter: The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the users list hasn't been reached..</param>
        /// <param name="cursor">Optional parameter: Paginate through collections of data by setting the `cursor` parameter to a `next_cursor` attribute returned by a previous request's `response_metadata`. Default value fetches the first "page" of the collection. See [pagination](/docs/pagination) for more detail..</param>
        /// <returns>Returns the ApiResponse of Models.ConversationsRepliesSuccessSchema response from the API call.</returns>
        public ApiResponse<Models.ConversationsRepliesSuccessSchema> ConversationsReplies(
                string token = null,
                string channel = null,
                double? ts = null,
                double? latest = null,
                double? oldest = null,
                bool? inclusive = null,
                int? limit = null,
                string cursor = null)
            => CoreHelper.RunTask(ConversationsRepliesAsync(token, channel, ts, latest, oldest, inclusive, limit, cursor));

        /// <summary>
        /// Retrieve a thread of messages posted to a conversation.
        /// </summary>
        /// <param name="token">Optional parameter: Authentication token. Requires scope: `conversations:history`.</param>
        /// <param name="channel">Optional parameter: Conversation ID to fetch thread from..</param>
        /// <param name="ts">Optional parameter: Unique identifier of a thread's parent message. `ts` must be the timestamp of an existing message with 0 or more replies. If there are no replies then just the single message referenced by `ts` will return - it is just an ordinary, unthreaded message..</param>
        /// <param name="latest">Optional parameter: End of time range of messages to include in results..</param>
        /// <param name="oldest">Optional parameter: Start of time range of messages to include in results..</param>
        /// <param name="inclusive">Optional parameter: Include messages with latest or oldest timestamp in results only when either timestamp is specified..</param>
        /// <param name="limit">Optional parameter: The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the users list hasn't been reached..</param>
        /// <param name="cursor">Optional parameter: Paginate through collections of data by setting the `cursor` parameter to a `next_cursor` attribute returned by a previous request's `response_metadata`. Default value fetches the first "page" of the collection. See [pagination](/docs/pagination) for more detail..</param>
        /// <param name="cancellationToken"> cancellationToken. </param>
        /// <returns>Returns the ApiResponse of Models.ConversationsRepliesSuccessSchema response from the API call.</returns>
        public async Task<ApiResponse<Models.ConversationsRepliesSuccessSchema>> ConversationsRepliesAsync(
                string token = null,
                string channel = null,
                double? ts = null,
                double? latest = null,
                double? oldest = null,
                bool? inclusive = null,
                int? limit = null,
                string cursor = null,
                CancellationToken cancellationToken = default)
            => await CreateApiCall<Models.ConversationsRepliesSuccessSchema>()
              .RequestBuilder(requestBuilder => requestBuilder
                  .Setup(HttpMethod.Get, "/conversations.replies")
                  .WithAuth("slackAuth")
                  .Parameters(parameters => parameters
                      .Header(header => header.Setup("Content-Type", "application/x-www-form-urlencoded"))
                      .Query(query => query.Setup("token", token))
                      .Query(query => query.Setup("channel", channel))
                      .Query(query => query.Setup("ts", ts))
                      .Query(query => query.Setup("latest", latest))
                      .Query(query => query.Setup("oldest", oldest))
                      .Query(query => query.Setup("inclusive", inclusive))
                      .Query(query => query.Setup("limit", limit))
                      .Query(query => query.Setup("cursor", cursor))))
              .ResponseHandler(responseHandler => responseHandler
                  .ErrorCase("0", CreateErrorCase("Typical error response", (errorReason, context) => new ConversationsRepliesErrorSchemaException(errorReason, context))))
              .ExecuteAsync(cancellationToken).ConfigureAwait(false);

        /// <summary>
        /// Sets the purpose for a conversation.
        /// </summary>
        /// <param name="token">Optional parameter: Authentication token. Requires scope: `conversations:write`.</param>
        /// <param name="channel">Optional parameter: Conversation to set the purpose of.</param>
        /// <param name="purpose">Optional parameter: A new, specialer purpose.</param>
        /// <returns>Returns the ApiResponse of Models.ConversationsSetPurposeSuccessSchema response from the API call.</returns>
        public ApiResponse<Models.ConversationsSetPurposeSuccessSchema> ConversationsSetPurpose(
                string token = null,
                string channel = null,
                string purpose = null)
            => CoreHelper.RunTask(ConversationsSetPurposeAsync(token, channel, purpose));

        /// <summary>
        /// Sets the purpose for a conversation.
        /// </summary>
        /// <param name="token">Optional parameter: Authentication token. Requires scope: `conversations:write`.</param>
        /// <param name="channel">Optional parameter: Conversation to set the purpose of.</param>
        /// <param name="purpose">Optional parameter: A new, specialer purpose.</param>
        /// <param name="cancellationToken"> cancellationToken. </param>
        /// <returns>Returns the ApiResponse of Models.ConversationsSetPurposeSuccessSchema response from the API call.</returns>
        public async Task<ApiResponse<Models.ConversationsSetPurposeSuccessSchema>> ConversationsSetPurposeAsync(
                string token = null,
                string channel = null,
                string purpose = null,
                CancellationToken cancellationToken = default)
            => await CreateApiCall<Models.ConversationsSetPurposeSuccessSchema>()
              .RequestBuilder(requestBuilder => requestBuilder
                  .Setup(HttpMethod.Post, "/conversations.setPurpose")
                  .WithAuth("slackAuth")
                  .Parameters(parameters => parameters
                      .Header(header => header.Setup("Content-Type", "application/x-www-form-urlencoded"))
                      .Header(header => header.Setup("token", token))
                      .Form(form => form.Setup("channel", channel))
                      .Form(form => form.Setup("purpose", purpose))))
              .ResponseHandler(responseHandler => responseHandler
                  .ErrorCase("0", CreateErrorCase("Typical error response", (errorReason, context) => new ConversationsSetPurposeErrorSchemaException(errorReason, context))))
              .ExecuteAsync(cancellationToken).ConfigureAwait(false);

        /// <summary>
        /// Sets the topic for a conversation.
        /// </summary>
        /// <param name="token">Optional parameter: Authentication token. Requires scope: `conversations:write`.</param>
        /// <param name="channel">Optional parameter: Conversation to set the topic of.</param>
        /// <param name="topic">Optional parameter: The new topic string. Does not support formatting or linkification..</param>
        /// <returns>Returns the ApiResponse of Models.ConversationsSetTopicSuccessSchema response from the API call.</returns>
        public ApiResponse<Models.ConversationsSetTopicSuccessSchema> ConversationsSetTopic(
                string token = null,
                string channel = null,
                string topic = null)
            => CoreHelper.RunTask(ConversationsSetTopicAsync(token, channel, topic));

        /// <summary>
        /// Sets the topic for a conversation.
        /// </summary>
        /// <param name="token">Optional parameter: Authentication token. Requires scope: `conversations:write`.</param>
        /// <param name="channel">Optional parameter: Conversation to set the topic of.</param>
        /// <param name="topic">Optional parameter: The new topic string. Does not support formatting or linkification..</param>
        /// <param name="cancellationToken"> cancellationToken. </param>
        /// <returns>Returns the ApiResponse of Models.ConversationsSetTopicSuccessSchema response from the API call.</returns>
        public async Task<ApiResponse<Models.ConversationsSetTopicSuccessSchema>> ConversationsSetTopicAsync(
                string token = null,
                string channel = null,
                string topic = null,
                CancellationToken cancellationToken = default)
            => await CreateApiCall<Models.ConversationsSetTopicSuccessSchema>()
              .RequestBuilder(requestBuilder => requestBuilder
                  .Setup(HttpMethod.Post, "/conversations.setTopic")
                  .WithAuth("slackAuth")
                  .Parameters(parameters => parameters
                      .Header(header => header.Setup("Content-Type", "application/x-www-form-urlencoded"))
                      .Header(header => header.Setup("token", token))
                      .Form(form => form.Setup("channel", channel))
                      .Form(form => form.Setup("topic", topic))))
              .ResponseHandler(responseHandler => responseHandler
                  .ErrorCase("0", CreateErrorCase("Typical error response", (errorReason, context) => new ConversationsSetTopicErrorSchemaException(errorReason, context))))
              .ExecuteAsync(cancellationToken).ConfigureAwait(false);

        /// <summary>
        /// Reverses conversation archival.
        /// </summary>
        /// <param name="token">Optional parameter: Authentication token. Requires scope: `conversations:write`.</param>
        /// <param name="channel">Optional parameter: ID of conversation to unarchive.</param>
        /// <returns>Returns the ApiResponse of Models.ConversationsUnarchiveSuccessSchema response from the API call.</returns>
        public ApiResponse<Models.ConversationsUnarchiveSuccessSchema> ConversationsUnarchive(
                string token = null,
                string channel = null)
            => CoreHelper.RunTask(ConversationsUnarchiveAsync(token, channel));

        /// <summary>
        /// Reverses conversation archival.
        /// </summary>
        /// <param name="token">Optional parameter: Authentication token. Requires scope: `conversations:write`.</param>
        /// <param name="channel">Optional parameter: ID of conversation to unarchive.</param>
        /// <param name="cancellationToken"> cancellationToken. </param>
        /// <returns>Returns the ApiResponse of Models.ConversationsUnarchiveSuccessSchema response from the API call.</returns>
        public async Task<ApiResponse<Models.ConversationsUnarchiveSuccessSchema>> ConversationsUnarchiveAsync(
                string token = null,
                string channel = null,
                CancellationToken cancellationToken = default)
            => await CreateApiCall<Models.ConversationsUnarchiveSuccessSchema>()
              .RequestBuilder(requestBuilder => requestBuilder
                  .Setup(HttpMethod.Post, "/conversations.unarchive")
                  .WithAuth("slackAuth")
                  .Parameters(parameters => parameters
                      .Header(header => header.Setup("Content-Type", "application/x-www-form-urlencoded"))
                      .Header(header => header.Setup("token", token))
                      .Form(form => form.Setup("channel", channel))))
              .ResponseHandler(responseHandler => responseHandler
                  .ErrorCase("0", CreateErrorCase("Typical error response", (errorReason, context) => new ConversationsUnarchiveErrorSchemaException(errorReason, context))))
              .ExecuteAsync(cancellationToken).ConfigureAwait(false);
    }
}