// <copyright file="FilesController.cs" company="APIMatic">
// SlackWebApi.Standard
//
// This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
// </copyright>
using APIMatic.Core;
using APIMatic.Core.Utilities;
using SlackWebApi.Standard.Exceptions;
using SlackWebApi.Standard.Http.Response;
using System.Net.Http;
using System.Threading;
using System.Threading.Tasks;

namespace SlackWebApi.Standard.Controllers
{
    /// <summary>
    /// FilesController.
    /// </summary>
    public class FilesController : BaseController
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="FilesController"/> class.
        /// </summary>
        internal FilesController(GlobalConfiguration globalConfiguration) : base(globalConfiguration) { }

        /// <summary>
        /// Deletes a file.
        /// </summary>
        /// <param name="token">Optional parameter: Authentication token. Requires scope: `files:write:user`.</param>
        /// <param name="file">Optional parameter: ID of file to delete..</param>
        /// <returns>Returns the ApiResponse of Models.FilesDeleteSchema response from the API call.</returns>
        public ApiResponse<Models.FilesDeleteSchema> FilesDelete(
                string token = null,
                string file = null)
            => CoreHelper.RunTask(FilesDeleteAsync(token, file));

        /// <summary>
        /// Deletes a file.
        /// </summary>
        /// <param name="token">Optional parameter: Authentication token. Requires scope: `files:write:user`.</param>
        /// <param name="file">Optional parameter: ID of file to delete..</param>
        /// <param name="cancellationToken"> cancellationToken. </param>
        /// <returns>Returns the ApiResponse of Models.FilesDeleteSchema response from the API call.</returns>
        public async Task<ApiResponse<Models.FilesDeleteSchema>> FilesDeleteAsync(
                string token = null,
                string file = null,
                CancellationToken cancellationToken = default)
            => await CreateApiCall<Models.FilesDeleteSchema>()
              .RequestBuilder(requestBuilder => requestBuilder
                  .Setup(HttpMethod.Post, "/files.delete")
                  .WithAuth("slackAuth")
                  .Parameters(parameters => parameters
                      .Header(header => header.Setup("Content-Type", "application/x-www-form-urlencoded"))
                      .Header(header => header.Setup("token", token))
                      .Form(form => form.Setup("file", file))))
              .ResponseHandler(responseHandler => responseHandler
                  .ErrorCase("0", CreateErrorCase("Typical error response", (errorReason, context) => new FilesDeleteErrorSchemaException(errorReason, context))))
              .ExecuteAsync(cancellationToken).ConfigureAwait(false);

        /// <summary>
        /// Gets information about a file.
        /// </summary>
        /// <param name="token">Optional parameter: Authentication token. Requires scope: `files:read`.</param>
        /// <param name="file">Optional parameter: Specify a file by providing its ID..</param>
        /// <param name="count">Optional parameter: .</param>
        /// <param name="page">Optional parameter: .</param>
        /// <param name="limit">Optional parameter: The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the list hasn't been reached..</param>
        /// <param name="cursor">Optional parameter: Parameter for pagination. File comments are paginated for a single file. Set `cursor` equal to the `next_cursor` attribute returned by the previous request's `response_metadata`. This parameter is optional, but pagination is mandatory: the default value simply fetches the first "page" of the collection of comments. See [pagination](/docs/pagination) for more details..</param>
        /// <returns>Returns the ApiResponse of Models.FilesInfoSchema response from the API call.</returns>
        public ApiResponse<Models.FilesInfoSchema> FilesInfo(
                string token = null,
                string file = null,
                string count = null,
                string page = null,
                int? limit = null,
                string cursor = null)
            => CoreHelper.RunTask(FilesInfoAsync(token, file, count, page, limit, cursor));

        /// <summary>
        /// Gets information about a file.
        /// </summary>
        /// <param name="token">Optional parameter: Authentication token. Requires scope: `files:read`.</param>
        /// <param name="file">Optional parameter: Specify a file by providing its ID..</param>
        /// <param name="count">Optional parameter: .</param>
        /// <param name="page">Optional parameter: .</param>
        /// <param name="limit">Optional parameter: The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the list hasn't been reached..</param>
        /// <param name="cursor">Optional parameter: Parameter for pagination. File comments are paginated for a single file. Set `cursor` equal to the `next_cursor` attribute returned by the previous request's `response_metadata`. This parameter is optional, but pagination is mandatory: the default value simply fetches the first "page" of the collection of comments. See [pagination](/docs/pagination) for more details..</param>
        /// <param name="cancellationToken"> cancellationToken. </param>
        /// <returns>Returns the ApiResponse of Models.FilesInfoSchema response from the API call.</returns>
        public async Task<ApiResponse<Models.FilesInfoSchema>> FilesInfoAsync(
                string token = null,
                string file = null,
                string count = null,
                string page = null,
                int? limit = null,
                string cursor = null,
                CancellationToken cancellationToken = default)
            => await CreateApiCall<Models.FilesInfoSchema>()
              .RequestBuilder(requestBuilder => requestBuilder
                  .Setup(HttpMethod.Get, "/files.info")
                  .WithAuth("slackAuth")
                  .Parameters(parameters => parameters
                      .Header(header => header.Setup("Content-Type", "application/x-www-form-urlencoded"))
                      .Query(query => query.Setup("token", token))
                      .Query(query => query.Setup("file", file))
                      .Query(query => query.Setup("count", count))
                      .Query(query => query.Setup("page", page))
                      .Query(query => query.Setup("limit", limit))
                      .Query(query => query.Setup("cursor", cursor))))
              .ResponseHandler(responseHandler => responseHandler
                  .ErrorCase("0", CreateErrorCase("Typical error response", (errorReason, context) => new FilesInfoErrorSchemaException(errorReason, context))))
              .ExecuteAsync(cancellationToken).ConfigureAwait(false);

        /// <summary>
        /// List for a team, in a channel, or from a user with applied filters.
        /// </summary>
        /// <param name="token">Optional parameter: Authentication token. Requires scope: `files:read`.</param>
        /// <param name="user">Optional parameter: Filter files created by a single user..</param>
        /// <param name="channel">Optional parameter: Filter files appearing in a specific channel, indicated by its ID..</param>
        /// <param name="tsFrom">Optional parameter: Filter files created after this timestamp (inclusive)..</param>
        /// <param name="tsTo">Optional parameter: Filter files created before this timestamp (inclusive)..</param>
        /// <param name="types">Optional parameter: Filter files by type ([see below](#file_types)). You can pass multiple values in the types argument, like `types=spaces,snippets`.The default value is `all`, which does not filter the list..</param>
        /// <param name="count">Optional parameter: .</param>
        /// <param name="page">Optional parameter: .</param>
        /// <param name="showFilesHiddenByLimit">Optional parameter: Show truncated file info for files hidden due to being too old, and the team who owns the file being over the file limit..</param>
        /// <returns>Returns the ApiResponse of Models.FilesListSchema response from the API call.</returns>
        public ApiResponse<Models.FilesListSchema> FilesList(
                string token = null,
                string user = null,
                string channel = null,
                double? tsFrom = null,
                double? tsTo = null,
                string types = null,
                string count = null,
                string page = null,
                bool? showFilesHiddenByLimit = null)
            => CoreHelper.RunTask(FilesListAsync(token, user, channel, tsFrom, tsTo, types, count, page, showFilesHiddenByLimit));

        /// <summary>
        /// List for a team, in a channel, or from a user with applied filters.
        /// </summary>
        /// <param name="token">Optional parameter: Authentication token. Requires scope: `files:read`.</param>
        /// <param name="user">Optional parameter: Filter files created by a single user..</param>
        /// <param name="channel">Optional parameter: Filter files appearing in a specific channel, indicated by its ID..</param>
        /// <param name="tsFrom">Optional parameter: Filter files created after this timestamp (inclusive)..</param>
        /// <param name="tsTo">Optional parameter: Filter files created before this timestamp (inclusive)..</param>
        /// <param name="types">Optional parameter: Filter files by type ([see below](#file_types)). You can pass multiple values in the types argument, like `types=spaces,snippets`.The default value is `all`, which does not filter the list..</param>
        /// <param name="count">Optional parameter: .</param>
        /// <param name="page">Optional parameter: .</param>
        /// <param name="showFilesHiddenByLimit">Optional parameter: Show truncated file info for files hidden due to being too old, and the team who owns the file being over the file limit..</param>
        /// <param name="cancellationToken"> cancellationToken. </param>
        /// <returns>Returns the ApiResponse of Models.FilesListSchema response from the API call.</returns>
        public async Task<ApiResponse<Models.FilesListSchema>> FilesListAsync(
                string token = null,
                string user = null,
                string channel = null,
                double? tsFrom = null,
                double? tsTo = null,
                string types = null,
                string count = null,
                string page = null,
                bool? showFilesHiddenByLimit = null,
                CancellationToken cancellationToken = default)
            => await CreateApiCall<Models.FilesListSchema>()
              .RequestBuilder(requestBuilder => requestBuilder
                  .Setup(HttpMethod.Get, "/files.list")
                  .WithAuth("slackAuth")
                  .Parameters(parameters => parameters
                      .Header(header => header.Setup("Content-Type", "application/x-www-form-urlencoded"))
                      .Query(query => query.Setup("token", token))
                      .Query(query => query.Setup("user", user))
                      .Query(query => query.Setup("channel", channel))
                      .Query(query => query.Setup("ts_from", tsFrom))
                      .Query(query => query.Setup("ts_to", tsTo))
                      .Query(query => query.Setup("types", types))
                      .Query(query => query.Setup("count", count))
                      .Query(query => query.Setup("page", page))
                      .Query(query => query.Setup("show_files_hidden_by_limit", showFilesHiddenByLimit))))
              .ResponseHandler(responseHandler => responseHandler
                  .ErrorCase("0", CreateErrorCase("Typical error response", (errorReason, context) => new FilesListErrorSchemaException(errorReason, context))))
              .ExecuteAsync(cancellationToken).ConfigureAwait(false);

        /// <summary>
        /// Revokes public/external sharing access for a file.
        /// </summary>
        /// <param name="token">Optional parameter: Authentication token. Requires scope: `files:write:user`.</param>
        /// <param name="file">Optional parameter: File to revoke.</param>
        /// <returns>Returns the ApiResponse of Models.FilesRevokePublicUrlSchema response from the API call.</returns>
        public ApiResponse<Models.FilesRevokePublicUrlSchema> FilesRevokePublicUrl(
                string token = null,
                string file = null)
            => CoreHelper.RunTask(FilesRevokePublicUrlAsync(token, file));

        /// <summary>
        /// Revokes public/external sharing access for a file.
        /// </summary>
        /// <param name="token">Optional parameter: Authentication token. Requires scope: `files:write:user`.</param>
        /// <param name="file">Optional parameter: File to revoke.</param>
        /// <param name="cancellationToken"> cancellationToken. </param>
        /// <returns>Returns the ApiResponse of Models.FilesRevokePublicUrlSchema response from the API call.</returns>
        public async Task<ApiResponse<Models.FilesRevokePublicUrlSchema>> FilesRevokePublicUrlAsync(
                string token = null,
                string file = null,
                CancellationToken cancellationToken = default)
            => await CreateApiCall<Models.FilesRevokePublicUrlSchema>()
              .RequestBuilder(requestBuilder => requestBuilder
                  .Setup(HttpMethod.Post, "/files.revokePublicURL")
                  .WithAuth("slackAuth")
                  .Parameters(parameters => parameters
                      .Header(header => header.Setup("Content-Type", "application/x-www-form-urlencoded"))
                      .Header(header => header.Setup("token", token))
                      .Form(form => form.Setup("file", file))))
              .ResponseHandler(responseHandler => responseHandler
                  .ErrorCase("0", CreateErrorCase("Typical error response", (errorReason, context) => new FilesRevokePublicUrlErrorSchemaException(errorReason, context))))
              .ExecuteAsync(cancellationToken).ConfigureAwait(false);

        /// <summary>
        /// Enables a file for public/external sharing.
        /// </summary>
        /// <param name="token">Optional parameter: Authentication token. Requires scope: `files:write:user`.</param>
        /// <param name="file">Optional parameter: File to share.</param>
        /// <returns>Returns the ApiResponse of Models.FilesSharedPublicUrlSchema response from the API call.</returns>
        public ApiResponse<Models.FilesSharedPublicUrlSchema> FilesSharedPublicUrl(
                string token = null,
                string file = null)
            => CoreHelper.RunTask(FilesSharedPublicUrlAsync(token, file));

        /// <summary>
        /// Enables a file for public/external sharing.
        /// </summary>
        /// <param name="token">Optional parameter: Authentication token. Requires scope: `files:write:user`.</param>
        /// <param name="file">Optional parameter: File to share.</param>
        /// <param name="cancellationToken"> cancellationToken. </param>
        /// <returns>Returns the ApiResponse of Models.FilesSharedPublicUrlSchema response from the API call.</returns>
        public async Task<ApiResponse<Models.FilesSharedPublicUrlSchema>> FilesSharedPublicUrlAsync(
                string token = null,
                string file = null,
                CancellationToken cancellationToken = default)
            => await CreateApiCall<Models.FilesSharedPublicUrlSchema>()
              .RequestBuilder(requestBuilder => requestBuilder
                  .Setup(HttpMethod.Post, "/files.sharedPublicURL")
                  .WithAuth("slackAuth")
                  .Parameters(parameters => parameters
                      .Header(header => header.Setup("Content-Type", "application/x-www-form-urlencoded"))
                      .Header(header => header.Setup("token", token))
                      .Form(form => form.Setup("file", file))))
              .ResponseHandler(responseHandler => responseHandler
                  .ErrorCase("0", CreateErrorCase("Typical error response", (errorReason, context) => new FilesSharedPublicUrlErrorSchemaException(errorReason, context))))
              .ExecuteAsync(cancellationToken).ConfigureAwait(false);

        /// <summary>
        /// Uploads or creates a file.
        /// </summary>
        /// <param name="token">Optional parameter: Authentication token. Requires scope: `files:write:user`.</param>
        /// <param name="file">Optional parameter: File contents via `multipart/form-data`. If omitting this parameter, you must submit `content`..</param>
        /// <param name="content">Optional parameter: File contents via a POST variable. If omitting this parameter, you must provide a `file`..</param>
        /// <param name="filetype">Optional parameter: A [file type](/types/file#file_types) identifier..</param>
        /// <param name="filename">Optional parameter: Filename of file..</param>
        /// <param name="title">Optional parameter: Title of file..</param>
        /// <param name="initialComment">Optional parameter: The message text introducing the file in specified `channels`..</param>
        /// <param name="channels">Optional parameter: Comma-separated list of channel names or IDs where the file will be shared..</param>
        /// <param name="threadTs">Optional parameter: Provide another message's `ts` value to upload this file as a reply. Never use a reply's `ts` value; use its parent instead..</param>
        /// <returns>Returns the ApiResponse of Models.FilesUploadSchema response from the API call.</returns>
        public ApiResponse<Models.FilesUploadSchema> FilesUpload(
                string token = null,
                string file = null,
                string content = null,
                string filetype = null,
                string filename = null,
                string title = null,
                string initialComment = null,
                string channels = null,
                double? threadTs = null)
            => CoreHelper.RunTask(FilesUploadAsync(token, file, content, filetype, filename, title, initialComment, channels, threadTs));

        /// <summary>
        /// Uploads or creates a file.
        /// </summary>
        /// <param name="token">Optional parameter: Authentication token. Requires scope: `files:write:user`.</param>
        /// <param name="file">Optional parameter: File contents via `multipart/form-data`. If omitting this parameter, you must submit `content`..</param>
        /// <param name="content">Optional parameter: File contents via a POST variable. If omitting this parameter, you must provide a `file`..</param>
        /// <param name="filetype">Optional parameter: A [file type](/types/file#file_types) identifier..</param>
        /// <param name="filename">Optional parameter: Filename of file..</param>
        /// <param name="title">Optional parameter: Title of file..</param>
        /// <param name="initialComment">Optional parameter: The message text introducing the file in specified `channels`..</param>
        /// <param name="channels">Optional parameter: Comma-separated list of channel names or IDs where the file will be shared..</param>
        /// <param name="threadTs">Optional parameter: Provide another message's `ts` value to upload this file as a reply. Never use a reply's `ts` value; use its parent instead..</param>
        /// <param name="cancellationToken"> cancellationToken. </param>
        /// <returns>Returns the ApiResponse of Models.FilesUploadSchema response from the API call.</returns>
        public async Task<ApiResponse<Models.FilesUploadSchema>> FilesUploadAsync(
                string token = null,
                string file = null,
                string content = null,
                string filetype = null,
                string filename = null,
                string title = null,
                string initialComment = null,
                string channels = null,
                double? threadTs = null,
                CancellationToken cancellationToken = default)
            => await CreateApiCall<Models.FilesUploadSchema>()
              .RequestBuilder(requestBuilder => requestBuilder
                  .Setup(HttpMethod.Post, "/files.upload")
                  .WithAuth("slackAuth")
                  .Parameters(parameters => parameters
                      .Header(header => header.Setup("Content-Type", "application/x-www-form-urlencoded"))
                      .Form(form => form.Setup("token", token))
                      .Form(form => form.Setup("file", file))
                      .Form(form => form.Setup("content", content))
                      .Form(form => form.Setup("filetype", filetype))
                      .Form(form => form.Setup("filename", filename))
                      .Form(form => form.Setup("title", title))
                      .Form(form => form.Setup("initial_comment", initialComment))
                      .Form(form => form.Setup("channels", channels))
                      .Form(form => form.Setup("thread_ts", threadTs))))
              .ResponseHandler(responseHandler => responseHandler
                  .ErrorCase("0", CreateErrorCase("Typical error response", (errorReason, context) => new FilesUploadErrorSchemaException(errorReason, context))))
              .ExecuteAsync(cancellationToken).ConfigureAwait(false);
    }
}